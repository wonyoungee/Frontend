<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
    <script>
    /*
    자바 설계도(클래스) => 재사용성

    class Product{
        private String carname="pony";
        public Product(){}
        public Product(String carname){
            this.carname= carname;
        }
        public void print(){}
    }

    메모리 load ... (new)
    Product p = new Product();
    Product p2 = new Product("pony2");
    p.print();
    p2.print();

    ///////////////////////////////////////////////////////////////////////////////////////////////////

    javaScript >> 객체지향언어(OOP)

    * 클래스 정의 3가지 방법

    1. 프로토타입 방식 :   일반적인 클래스 제작 방법
                                        인스턴스마다 공통된 메서드를 공유해서 사용하는 장점
                                        Jquery 도 prototype 방식으로 설계

        function 클래스이름() {  // function Car(){}
            this.프로퍼티1 = 초기값;
            this.프로퍼티2 = 초기값;
        }

        클래스이름.prototype.메서드1 = function() {}
        클래스이름.prototype.메서드2 = function() {}

        var 인스턴스 = new 클래스이름();
        var carObj = new Car();
        var carObj2 = new Car();
        var carObj3 = new Car();


    2. 함수 방식 :  간단한 클래스 제작 시 사용
                           인스턴스마다 메서드가 독립적으로 만들어지는 단점

    ** 클래스 : function Car(){ this.name = , this.age=}
    ** 함수 : function car(){}

    function 클래스이름() {
        this.프로퍼티1 = 초기값;
        this.프로퍼티2 = 초기값;
        this.메서드1 = function() {}
        this.메서드2 = function() {}
    }

    var 인스턴스 = new 클래스이름();
    var carObj = new Car();
    var carObj2 = new Car();
    var carObj3 = new Car();


    *****************중요!!*****************
    3. 리터럴 방식 :   클래스 만드는 용도는 아니며 주로 여러개의 매개변수를 그룹으로 묶어 함수의 매개변수로 보낼때
                                정의와 함께 인스턴스가 만들어지는 장점이 있음. 단, 인스턴스는 오직 하나
                                재사용 불가. 1회성.
                                가장 편리한 방법 (심플함)
                                (초보자에게도 중요 ^^)


    4. ECMA6 버전부터 : class 키워드 제공

    class Person {
        constructor(name) {
            this._name = name;
        }
        sayHi() {
            console.log(`Hi! ${this._name}`);
        }
    }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    [ javascript 객체 생성 방법]

    1.오브젝트 리터럴 방식 (객체를 만드는 방법): 클래스 생성과 동시에 객체가 만들어져요 => 재사용 불가
    1.1 리터럴 방식 >> 제일 간단한 방법 > var obj = {}; //var objarr = [] 배열
    1.2 JSON 표기 : {} >> JSON: JavaScript Object Notation
    ex) var myObj = { "name":"John", "age":31, "city":"New York" };     // myObj라는 객체

    TIP) JSON >> XML (텍스트 기반의 형식화된 문서 제공)
    XML :이기종간의 데이터 호환 (한 때는 서점 : xml webservice)

    다른 이야기 >> JSON
    객체지향언어 장점 : 설계도 (재사용성)
    *오브젝트 리터럴 방식 : 재사용을 지원하는 않는다
    *설계도를 생성과 동시에 객체 생성(장점 : 편하고 , 빠르다 )
    *설계도를 미리 만들어 놓고 재사용하는 방식은 아니다
    *설계도당 하나의 객체만 생성 사용 (only object)

    var product = {}; //Product p = new Product();

    var product2 = {제품명:'사과',년도:'2018',원산지:'대구'};

    var 인스턴스 ={
        프로퍼티:초기값,
        프로퍼티:초기값,
        .....
        메서드:function(){},
        메서드:function(){}....
    }

    리터럴 방식 > 선언과 동시에 인스턴스 자동 생성
    var 인스턴스 = {}
    특징 : 생성자 존재하지 않는다. 프로퍼티와 메서드만 정의 가능.
    단점 : 객체 하나 생성(재사용성 없다)
    접근방법 : 인스턴스이름.자원 >> product2.제품명
    */


        let product = { 제품명: '사과', 년도: '2000', 원산지: '대구' };
        /*
         * <c#, java라면...>
         * class Product {private string 제품명; ...}
         * Product p = new Product();
         */
        console.log(product);
        document.write(product.제품명 + "<br>");
        document.write(product.년도 + "<br>");
        document.write(product.원산지 + "<br>");
        document.write(product.toString() + "<br>");    //[object Object]

        let Person = {
            name: "홍길동",
            addr: "서울시 강남구 역삼동",
            eat: function (food) {
                document.write(this.name + " / " + this.addr + " / " + food + " 냠냠");   // this == Person    함수에서는 반드시 this로 자원 접근!
            } //함수는 만들 수 있지만 주로 쓰진 않음..!
        };

        Person.eat("사과");

        // 속성 제거 기능
        // Map
        delete (product.년도);
        console.log(product);

        // Array    for(let index in Array){}

        // *** Point ***
        for (let key in product) {
            console.log("key : " + key);    // key
            console.log(product[key]);  // value (Map처럼 바라봄)
        }

        for (let key in Person) {
            console.log("key : " + key + "=" + Person[key]);
        }

        // JSON 객체
        // 외부 API 제공 (제공 데이터 : xml or json >> 서울시 공공데이터, 대법원 판례, 날씨정보 ...)
        // KEY POINT : 제공받은 xml or json 객체를 원하는 데이터만 추출하는 가공을 통해 화면에 출력
        // 반대인 경우 ... REST API 서버

        var Member = {};    // 빈 객체
        Member.name = "hong"    // {name : "hong"};
        console.log(Member.name);

        Member.age = 100;

        Member.print = function () {
            document.write("<br>" + this.name + " / " + this.age + "<br>");
        }

        Member.print();

        // ***** POINT *****
        // 객체가 객체를 가질 수 있음.
        // 객체가 배열을 가질 수 있음.
        // c#으로 보자면 ... class Member {private Car car; List<Car> list;}

        /////////////////////////////////////////////////////////////////////
        // 학점을 담는 객체 만들기
        let Grade = {
            list: {
                "hong": 100,
                "kim": 83,
                "park" : 30
            },
            show: function () {
                for (let key in this.list) {
                    document.write(key + " : " + this.list[key] + "<br>");
                }
            }
        }

        Grade.show();
        var listobj = Grade.list    // 객체 리턴
        for (let key in listhobj) {
            document.write(key + " : " + this.listobj[key] + "<br>");
        }
    </script>
</head>
<body>

</body>
</html>